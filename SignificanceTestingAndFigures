## SENM Galezo: Significance Testing and Figures
## Ali Galezo
## Created: 14 Dec 2018
## Last modified: 4 Feb 2018

library(dplyr)
library(ggplot2)
library(lazyeval)
library(gridExtra)

## Prepare environment.
options(stringsAsFactors = FALSE)
num_sim <- 1000

## Load files.
observed <- read.csv("real_network_metrics_full.csv")
expected <- read.csv("all_random_metrics_full.csv")
dolphins <- unique(observed$ego)


########################################################################
## Summary stats
########################################################################

observed %>%
  group_by(sex) %>%
  summarize(mean_degree = mean(mixdegree),
            sd_degree = sd(mixdegree),
            n = n(),
            se_degree = sd_degree/sqrt(n),
            min_degree = min(mixdegree),
            max_degree = max(mixdegree))

########################################################################
## Observed vs. expected social network metrics
########################################################################

metrics <- c("mixdegree","ss_degree","os_degree","mixstrength","ss_strength","os_strength","os_strength_kin","os_strength_nonkin","mixcc","percent_close_kin")

pVals <- data.frame(metric = rep(metrics, each = 2),
                    sex = rep(c("FEMALE","MALE"), length(metrics)))

#bonferroni <- nrow(pVals)

sigTester <- function(metric, sex){
  # This function calculates the p-value according to the rule P = (b + 1)/(m + 1),
  # Where b = number times a permuted value is more extreme than the observed value, and m = number of permutations.
  sex_ <- sex
  expected_vals <-
    expected %>%
    group_by(sex, iteration) %>%
    summarize_(mean = interp(~mean(var, na.rm = TRUE), var = as.name(metric))) %>%
    filter(sex == sex_) %>%
    pull(mean)
  observed_val <-
    observed %>%
    group_by(sex) %>%
    summarize_(observed_mean = interp(~mean(var, na.rm = TRUE), var = as.name(metric))) %>%
    filter(sex == sex_) %>%
    pull(observed_mean)
  extreme <- ifelse(observed_val >= median(expected_vals),
                    sum(expected_vals > observed_val),
                    sum(observed_val > expected_vals))
  (extreme + 1) / (num_sim + 1)
}

pVals$p <- mapply(sigTester,
                  metric = pVals$metric,
                  sex = pVals$sex)
pVals$adjusted_p <- p.adjust(pVals$p, "bonferroni")

#pVals$adjusted_p <- round(pVals$adjusted_p, 4)

# P-values greater than 1 can occur as a result of Bonferroni corrections.

########################################################################
## Figure 3 plots (observed vs. expected social network metrics)
########################################################################

## Titles
titles <- data.frame(short = metrics,
                     long = c("Number of Associates", "Number of Same-Sex Associates", "Number of Opposite-Sex Associates",
                              "Association Strength", "Same-Sex Strength", "Opposite-Sex Strength", "Opposite-Sex Strength (kin only)", "Opposite-Sex Strength (nonkin only)",
                              "Clustering Coefficient","Proportion of Available Close Kin\nAssociated With"))

## Axes
axes <- list(ss_degree = list(breaks_x = c(9,12,15,18,21), limits_x = c(8, 22)),
             os_degree = list(breaks_x = c(7,10,13,16,19), limits_x = c(6.9, 19.5)),
             mixstrength = list(breaks_x = seq(0.5, 1.5, 0.25), limits_x = c(0.5,1.5)),
             mixcc = list(breaks_x = seq(0.25,0.45,0.05), limits_x = c(0.23,0.45)),
             percent_close_kin = list(breaks_x = seq(0,0.7,0.2), limits_x = c(-0.05,0.7))
)

## Function to generate plots
SENMplot <- function(metric, sex){
  sex_ <- sex
  expected_vals <-
    expected %>%
    group_by(sex, iteration) %>%
    summarize_(mean = interp(~mean(var, na.rm = TRUE), var = as.name(metric))) %>%
    filter(sex == sex_) %>%
    pull(mean)
  observed_val <-
    observed %>%
    group_by(sex) %>%
    summarize_(observed_mean = interp(~mean(var, na.rm = TRUE), var = as.name(metric))) %>%
    filter(sex == sex_) %>%
    pull(observed_mean)
  observed_se <- 
    observed %>%
    filter(sex == sex_) %>%
    summarize_(n = ~n(),
               observed_sd = interp(~sd(var, na.rm = TRUE), var = as.name(metric))) %>%
    mutate(observed_se = observed_sd / sqrt(n)) %>%
    pull(observed_se)
  plot_data <- data.frame(value = c(expected_vals, observed_val),
                          identity = c(rep(" Expected Mean ", num_sim),
                                       " Observed Mean \u00B1 SE "))
  ggplot(plot_data) +
    geom_density(aes(x = value, fill = identity)) +
    geom_vline(xintercept = observed_val, color = "black", linetype = "solid", size = 0.8) +
    geom_vline(xintercept = observed_val + observed_se, color = "black", linetype = "dashed", size = 0.8) +
    geom_vline(xintercept = observed_val - observed_se, color = "black", linetype = "dashed", size = 0.8) +
    xlab(titles[titles$short == metric,]$long) +
    ylab("Density") +
    ggtitle(tools::toTitleCase(tolower(sex))) +
    scale_x_continuous(breaks = axes[[metric]]$breaks_x, limits = axes[[metric]]$limits_x) +
    scale_y_continuous(expand = c(0,0)) +
    scale_fill_manual(values = c("gray", "black")) +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5),
          legend.title=element_blank())
}

## Same-sex degree
ggpubr::ggarrange(SENMplot("ss_degree", "FEMALE"),
                  SENMplot("ss_degree", "MALE"),
                  ncol = 2, nrow = 1, common.legend = TRUE, legend = "bottom")

## Opposite-sex degree
ggpubr::ggarrange(SENMplot("os_degree", "FEMALE"),
                  SENMplot("os_degree", "MALE"),
                  ncol = 2, nrow = 1, common.legend = TRUE, legend = "bottom")

## Strength
ggpubr::ggarrange(SENMplot("mixstrength", "FEMALE"),
                  SENMplot("mixstrength", "MALE"),
                  ncol = 2, nrow = 1, common.legend = TRUE, legend = "bottom")

## Clustering coefficient
ggpubr::ggarrange(SENMplot("mixcc", "FEMALE"),
                  SENMplot("mixcc", "MALE"),
                  ncol = 2, nrow = 1, common.legend = TRUE, legend = "bottom")

## Percent close kin associated with
ggpubr::ggarrange(SENMplot("percent_close_kin", "FEMALE"),
                  SENMplot("percent_close_kin", "MALE"),
                  ncol = 2, nrow = 1, common.legend = TRUE, legend = "bottom")


########################################################################
## Compare 1) strength of same-sex bonds and 2) clustering coefficients in males vs. females
########################################################################

## Calculate differential between observed and expected (positive value: observed is higher than expected)
combined <- merge(x = expected, y = observed, by = "ego")
combined$ss_strength_differential <- combined$ss_strength.y - combined$ss_strength.x
combined$cc_differential <- combined$mixcc.y - combined$mixcc.x
combined <-
  combined %>%
  group_by(ego) %>%
  summarize(strength_differential = mean(ss_strength_differential),
            cc_differential = mean(cc_differential),
            sex = max(sex.x))
## Strength of same-sex bonds:
perm::permTS(combined %>% filter(sex == "FEMALE") %>% pull(strength_differential),
             combined %>% filter(sex == "MALE") %>% pull(strength_differential),
             alternative = "two.sided", exact = TRUE)
## Clustering coefficients:
perm::permTS(combined %>% filter(sex == "FEMALE") %>% filter(!is.na(cc_differential)) %>% pull(cc_differential),
             combined %>% filter(sex == "MALE") %>% filter(!is.na(cc_differential)) %>% pull(cc_differential),
             alternative = "two.sided", exact = TRUE)


########################################################################
## Compare strength/abundance of mixed sex vs. opposite sex bonds
########################################################################

## Compare strengh of same-sex vs opposite-sex bonds
strengths <- data.frame(id = as.factor(rep(observed$ego, 2)),
                        class = as.factor(c(rep("opposite", nrow(observed)), rep("same", nrow(observed)))),
                        strength = c(observed$os_strength, observed$ss_strength))
coin::symmetry_test(strength ~ class | id, data = strengths, alternative = "two.sided")

## Compare abundance of same-sex vs. opposite-sex bonds
degrees <- data.frame(id = as.factor(rep(observed$ego, 2)),
                      class = as.factor(c(rep("opposite", nrow(observed)), rep("same", nrow(observed)))),
                      degree = c(observed$os_degree, observed$ss_degree))
coin::symmetry_test(degree ~ class | id, data = degrees, alternative = "less")
